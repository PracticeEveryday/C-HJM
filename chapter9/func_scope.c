#include <stdio.h>

// 파일 내에서 모두 접근이 가능하다!
int global_in_file = 123;
int a;
// 변수 이름이란 메로리 상의 어떤 공간을 의미하는 명칭이다.
// 프로그래밍 할때 컴퓨터 메모리 주소 자체를 직접 입력해 가면서 코딩하는 것은 매우 어렵다.
// 사람이 인식할 수 있는 인식자로서 변수의 이름으로 메모리 상의 공간을 접근해 사용할 수 있게 하는 존재이다!
// 변수를 통해 접근한느 것은 메모리 상의 어떤 공간이고 메모리 라는 것은 `주소`를 통해서 접근한다.(임의 접근)

// 함수 선언 프로토타입
int int_max(int i, int j);

// 함수 정의
// 컴파일 후 링킹 할 때 바디를 찾아 링커가 연결해준다.
int int_max(int i, int j)
{
  // 함수의 스콥 안에서만 볼 수 있고 사용할 수 있다.
  // 지역적으로 쓸 수 있는 지역 변수!
  int m;
  m = i > j ? i : j;
  return m;
}

int main()
{
  // m은 int_max에 선언되어 있는 변수다.
  // 유효한 스콥은 m이 선언되어 있는 블록 안에서만 유효하다!
  // 메인 함수에서는 invisable하다!
  // m = 123; <- because of stack frame

  // 변수는 변수를 사용할 수 있는 유효한 영역이 따로 있다.
  // 유효한 영역 안에서 변수를 볼 수 있고 사용할 수 있다.

  printf("처음 a %p\n", &a); // a의 주소를 알려주는 오퍼레이터
  // 주소를 보는 방법 %p(inter)

  // 바깥에 globally a가 선언되어 있더라도, 선언 된 블록 안에서 다시 선언되는 것이다!
  int a;
  a = int_max(1, 2);

  // m = 123;

  printf("%d\n", a);
  printf("%p\n", &a);

  int c = 3;
  printf("c: %d\n", c);
  printf("c: %p\n", &c);
  // 새로운 영역 만들기
  {
    a = int_max(4, 5);
    printf("%d\n", a);
    printf("%p\n", &a);

    int b = 2;
    int c = 5;
    printf("c: %d\n", c);
    printf("c: %p\n", &c); // c는 스코프 안에서 다시 할당하기에 주소 값이 바뀐다!!
    // 다른 변수가 된다! 메모리 주소가 다르니까!
  }

  printf("%d\n", a);
  printf("%p\n", &a);

  // 영역 밖으로 나오면 상위 스콥의 c를 바라보게 한다!
  printf("c: %d\n", c);
  printf("c: %p\n", &c);

  // 바깥 영역으로 나오면 없어진다. stack에서 빠지니까!
  // printf("%d\n", b);

  return 0;
}

// 실행 할 때마다 주소가 달라질 수 있다.
// OS가 프로그램을 실행할 때마다 빈 공간에 프로그램을 적재하고 실행시켜주는데
// 그때 항상 동일한 공간에 생성하는 것이 아니다!!

// 모든 영역에서 변수 이름을 항상 유니크하게 지으려고 하면 그것도 어려운 일이다!