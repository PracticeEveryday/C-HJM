#include <stdio.h>

int main()
{
  // 2차원 배열도 결국 메모리는 일차원으로 사용한다.
  int arr[2][3] = {{1, 2, 3},
                   {4, 5, 6}};

  // 위 아래는 동일하게 작동함.
  int arr2[2][3] = {1, 2, 3, 4, 5, 6};
  int arr3[2][3] = {1, 2};

  printf("%d\n", arr[1][1]);
  printf("%d\n", arr2[1][1]);
  printf("%d\n", arr3[1][1]);

  for (int j = 0; j < 2; ++j)
  {
    for (int i = 0; i < 3; ++i)
    {
      // inner loop uses i, why?
      // 내부적으로는 그냥 1차원이다.

      // j가 증가한 후 -> i가 전부 증가하는 형태이다. <- 이는 2차원 배열을 메모리에 할당하는 방식과 일치한다.
      // 이 형태가 메모리저 저장되어 있는 순서와 일치하면 훨씬 빨리 읽어온다.
      // 100만개 1000만개가 되면 차이가 많이 난다.

      // 즉 j를 바깥쪽 루프에 넣고 i를 안쪽 루프에 넣게 되는 것이다.
      // 메모리의 구조와 맞춰서 생각을 해보면 안쪽, 바깥쪽의 루프가 정해진다!
      printf("%d ", arr[j][i]);
    }
    printf("\n");
  }
  printf("\n");

  // 2차원 배열의 첫번째 주소를 포인터에 넣어 놓고 1차원 배열인 것처럼 사용할 수도 있다. // 내부적으로는 1차원 배열이니까!
  int *ptr = &arr[0][0];
  for (int k = 0; k < 6; ++k)
  {
    printf("%d ", ptr[k]);
  }
  printf("\n");

  // 3개 짜리의 크기가 나온 것이다.
  printf("%zd %zd\n", sizeof(arr), sizeof(arr[0]));
}